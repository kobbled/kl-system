PROGRAM systemlib
%NOBUSYLAMP
%COMMENT = 'system functs'
%NOLOCKGROUP
%NOPAUSE = COMMAND + TPENABLE + ERROR

%include systemvars.klt
%include systemlib.klt
%include systemlib.generics.klt

%from strings.klh %import rstrip, lstrip, i_to_s, bin_to_i
%include systemlib.klh
%include systemlib.datatype.klh

-- pi
%define M_PI      3.14159265358979323846 

BEGIN
END systemlib

ROUTINE system__date
  VAR
    tme   : INTEGER
    sec : INTEGER
    str    : STRING[30]
    secstr : STRING[4]
  BEGIN
    GET_TIME(tme)
    CNV_TIME_STR(tme,str)
    --strip out date DD-MMM-YYY
    str = SUB_STR(str,1,9)
    
    RETURN(rstrip(str))
  END system__date

ROUTINE system__time
  VAR
    tme, hr, mnt, sec   : INTEGER
    str    : STRING[30]
  BEGIN
    GET_TIME(tme)
    CNV_TIME_STR(tme,str)
    --parse out HH:MM: from DD-MMM-YYY HH:MM:
    str = SUB_STR(str,STR_LEN(str)-6,STR_LEN(str))
    str = rstrip(lstrip(str)) + ':'
    --get seconds
    sec = tme AND 31    -- 0000000000011111
    --seconds stored 2-second increments (0-29)
    -- double to convert to 0-59
    sec = sec * 2

    --combine into string HH:MM:SS
    IF sec < 10 THEN str = str + '0' ; ENDIF
    str = str + i_to_s(sec)
    
    RETURN(str)
  END system__time

ROUTINE system__pns_to_str
  VAR
    i : INTEGER
    sno : STRING[8]
    num : INTEGER
  BEGIN
    --create select number output
    sno =''
    --UOPO[11-18]
    FOR i=24 TO 31 DO
      IF OPIN[i] THEN sno = sno + '1'; ELSE sno = sno + '0'; ENDIF
    ENDFOR

    --if all SNO inputs are off add 1. select number output
    --should always be at least 1.
    num = bin_to_i(sno)
    IF num = 0 THEN
      num = 1
    ENDIF
    
    num = $SHELL_CFG.$JOB_BASE + num
    --return full name i.e. PNS1001 if $PNS_PROGRAM = PNS
    --$SHELL_CFG.$JOB_BASE = 1000 and UO[11] = TRUE
    RETURN($PNS_PROGRAM + i_to_s(num))
  END system__pns_to_str

-- only needed as a tp interface for setting SRs
ROUTINE system__set_string
  BEGIN
    RETURN(str_val)
  END system__set_string

ROUTINE system__set_leader_frame
  VAR
    entry, status : INTEGER
    p : POSITION IN GROUP[1]
  BEGIN
    p = frm
    SET_VAR(entry, '*SYSTEM*', '$CD_PAIR['+i_to_s(cd_pair_no)+'].$LEADER_FRM['+i_to_s(ldr_frm_no)+']', p, status)
  END system__set_leader_frame

ROUTINE system__get_leader_frame
  VAR
    entry, status : INTEGER
    p : POSITION IN GROUP[1]
  BEGIN
    GET_VAR(entry, '*SYSTEM*', '$CD_PAIR['+i_to_s(cd_pair_no)+'].$LEADER_FRM['+i_to_s(ldr_frm_no)+']', p, status)
    RETURN(p)
  END system__get_leader_frame


ROUTINE VEC
  VAR
    v : VECTOR
  BEGIN
    v.x = x; v.y = y; v.z = z;
    RETURN(v)
  END VEC

ROUTINE VEC2D
  VAR
    v : VECTOR
  BEGIN
    v.x = x; v.y = y; v.z = 0;
    RETURN(v)
  END VEC2D

ROUTINE compare_VEC
  BEGIN
    IF ((ABS(v2.x - v1.x) < tolerance) AND (ABS(v2.y - v1.y) < tolerance) AND &
       (ABS(v2.z - v1.z) < tolerance)) THEN
        RETURN(TRUE)
    ELSE
      RETURN(FALSE)
    ENDIF
  END compare_VEC

-- -----------
-- functions for t_DATA_TYPE type
-- -----------
  --callback functions for comparator

ROUTINE system__tdata_callback_int
  BEGIN
    RETURN(nde.int)
  END system__tdata_callback_int

ROUTINE system__tdata_callback_real
  BEGIN
    RETURN(nde.rl)
  END system__tdata_callback_real

ROUTINE system__tdata_callback_vec
  BEGIN
    --get euclidean distance
    RETURN(SQRT(nde.vec.x*nde.vec.x + nde.vec.y*nde.vec.y + nde.vec.z*nde.vec.z))
  END system__tdata_callback_vec

ROUTINE system__tdata_callback_pose
  BEGIN
    --get euclidean distance in 6dof
    RETURN(SQRT(nde.pos.x*nde.pos.x + nde.pos.y*nde.pos.y + nde.pos.z*nde.pos.z + (nde.pos.w*nde.pos.w)*M_PI/180 + (nde.pos.p*nde.pos.p)*M_PI/180 + (nde.pos.r*nde.pos.r)*M_PI/180))
  END system__tdata_callback_pose


ROUTINE system__tdata_glte
%define EPSILON 0.01
  BEGIN
    SELECT typ OF
      CASE(C_INT):
        impl_glte_body(data1,data2,comparator,system__tdata_callback_int,EPSILON)
      CASE(C_REAL):
        impl_glte_body(data1,data2,comparator,system__tdata_callback_real,EPSILON)
      CASE(C_VEC):
        impl_glte_body(data1,data2,comparator,system__tdata_callback_vec,EPSILON)
      CASE(C_POS):
        impl_glte_body(data1,data2,comparator,system__tdata_callback_pose,EPSILON)
      ELSE:
        WRITE TPERROR('Cannot compare type:', typ, ' for a t_DATA_TYPE struct')
    ENDSELECT
  END system__tdata_glte
